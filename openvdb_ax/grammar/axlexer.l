/*
Copyright (c) 2015-2019 DNEG

All rights reserved. This software is distributed under the
Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )

Redistributions of source code must retain the above copyright
and license notice and the following restrictions and disclaimer.

*     Neither the name of DNEG nor the names
of its contributors may be used to endorse or promote products derived
from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
IN NO EVENT SHALL THE COPYRIGHT HOLDERS' AND CONTRIBUTORS' AGGREGATE
LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
*/

%{
    #include <sstream>
    #include <openvdb_ax/ast/AST.h>
    #include <openvdb_ax/Exceptions.h>
    #include "axparser.h" /*generated by bison*/

    /// @note  Location tracking macro for axlloc token locations.
    ///   YY_USER_ACTION is called before any and each lexer action
    ///   is performed. Instead of manually tracking newlines, we
    ///   can simply scan for them in the current text held by axtext
    #define YY_USER_ACTION \
        axlloc.first_line = axlloc.last_line; \
        axlloc.first_column = axlloc.last_column; \
        for (int i = 0; axtext[i] != '\0'; i++) { \
            if (axtext[i] == '\n') { \
                axlloc.last_line++; \
                axlloc.last_column = 0; \
            } \
            else { \
                axlloc.last_column++; \
            } \
        }
%}

/* Option 'noyywrap' indicates that when EOF is hit, yyin does not
 * automatically reset to another file.
 */
%option noyywrap

/* Options 'nounput' and 'noinput' are useful for interactive session
 * support. We don't support or require this.
 */
%option nounput noinput

/* Option 'prefix' creates a C++ lexer with the given prefix, so that
 * we can link with other flex-generated lexers in the same application
 * without name conflicts.
 */
%option prefix="ax"

/* Some handy macros which define constant tokens
 */

/* All whitespace bar new lines:
 *   \t tabs, \v vertical tabs, \r carriage return, \f form feed (page break)
 * https://www.regular-expressions.info/refcharacters.html
 */
WHITESPACE  [ \t\v\r\f]+
LETTER      [a-zA-Z]
DIGIT       [0-9]
E           [eE][-+]?{DIGIT}+
NEWLINE     [\n]
COMMENT     "//".*

%%

";"                         { return SEMICOLON; }
"@"                         { return AT; }
"$"                         { return DOLLAR; }

"="                         { return EQUALS; }
"+"                         { return PLUS; }
"-"                         { return MINUS; }
"*"                         { return MULTIPLY; }
"/"                         { return DIVIDE; }
"%"                         { return MODULO; }
"&"                         { return BITAND; }
"|"                         { return BITOR; }
"^"                         { return BITXOR; }
"~"                         { return BITNOT; }

"=="                        { return EQUALSEQUALS; }
"!="                        { return NOTEQUALS; }
">"                         { return MORETHAN; }
"<"                         { return LESSTHAN; }
">="                        { return MORETHANOREQUAL; }
"<="                        { return LESSTHANOREQUAL; }

"+="                        { return PLUSEQUALS; }
"-="                        { return MINUSEQUALS; }
"*="                        { return MULTIPLYEQUALS; }
"/="                        { return DIVIDEEQUALS; }
"%="                        { return MODULOEQUALS; }
"&="                        { return BITANDEQUALS; }
"^="                        { return BITXOREQUALS; }
"|="                        { return BITOREQUALS; }

"++"                        { return PLUSPLUS; }
"--"                        { return MINUSMINUS; }

"&&"                        { return AND; }
"||"                        { return OR; }
"!"                         { return NOT; }

","                         { return COMMA; }

"("                         { return LPARENS; }
")"                         { return RPARENS; }
"{"                         { return LCURLY; }
"}"                         { return RCURLY; }
"["                         { return LSQUARE; }
"]"                         { return RSQUARE; }

".x"                        { return DOT_X; }
".y"                        { return DOT_Y; }
".z"                        { return DOT_Z; }
".r"                        { return DOT_X; }
".g"                        { return DOT_Y; }
".b"                        { return DOT_Z; }

"v@"                        { return V_AT; }
"f@"                        { return F_AT; }
"i@"                        { return I_AT; }
"s@"                        { return S_AT; }

"v$"                        { return V_DOLLAR; }
"f$"                        { return F_DOLLAR; }
"i$"                        { return I_DOLLAR; }
"s$"                        { return S_DOLLAR; }

"if"                        { return IF; }
"else"                      { return ELSE; }
"true"                      { return TRUE; }
"false"                     { return FALSE; }
"return"                    { return RETURN; }

"bool"                      { return BOOL; }
"short"                     { return SHORT; }
"int"                       { return INT; }
"long"                      { return LONG; }
"float"                     { return FLOAT; }
"double"                    { return DOUBLE; }
"string"                    { return STRING; }

"vec2i"                     { return VEC2I; }
"vec2f"                     { return VEC2F; }
"vec2d"                     { return VEC2D; }
"vec3i"                     { return VEC3I; }
"vec3f"                     { return VEC3F; }
"vec3d"                     { return VEC3D; }
"vec4i"                     { return VEC4I; }
"vec4f"                     { return VEC4F; }
"vec4d"                     { return VEC4D; }

"mat3f"                     { return MAT3F; }
"mat3d"                     { return MAT3D; }
"mat4f"                     { return MAT4F; }
"mat4d"                     { return MAT4D; }

 /*Tokens to support VEX Syntax*/
"vector"                    { return VEC3F; } /*VEX SUPPORT TOKENS*/
"matrix"                    { return MAT4F; }
"matrix3"                   { return MAT3F; }
"3@"                        { return M3F_AT; }
"4@"                        { return M4F_AT; }

 /*Deprecated Tokens*/
"vectorint"                 { return VEC3I; }
"vectorfloat"               { return VEC3F; }
"vectordouble"              { return VEC3D; }

 /* Reserved keywords */
"break"|"case"|"char"|"class"|"const"|"continue"|"def" | \
"default"|"do"|"double"|"enum"|"extern"|"for"|"friend" | \
"function"|"inline" |"private"|"protected"|"signed" | \
"sizeof"|"static"|"struct"|"switch"|"template"|"this" | \
"typedef"|"uniform"|"union"|"unsigned"|"until"|"virtual" | \
"void"|"while" {
    // @todo add a proper error manager to the parser
    std::ostringstream os;
    os << axlloc.first_line << ":" << axlloc.first_column
       << " Reserved keyword not currently implemented: '"
       << axtext << "'";
    OPENVDB_THROW(openvdb::LLVMSyntaxError, os.str());
}

{WHITESPACE}                { } /* ignore whitespace */
{COMMENT}                   { } /* ignore //-style one-line comments */
{NEWLINE}                   { } /* ignore newlines */

\"(\\.|[^\\"\n])*\"         {
                                axlval.string = strndup(axtext+1, axleng-2);
                                return L_STRING;
                            }

{DIGIT}+s                   {
                                axlval.string = strdup(axtext);
                                return L_SHORT;
                            }

{DIGIT}+                    {
                                axlval.string = strdup(axtext);
                                return L_INT;
                            }

{DIGIT}+l                   {
                                axlval.string = strdup(axtext);
                                return L_LONG;
                            }

"."{DIGIT}+f         |
{DIGIT}+"."{DIGIT}*f |
{DIGIT}+("."{DIGIT}+)?{E}+f     {
                                    axlval.string = strdup(axtext);
                                    return L_FLOAT;
                                }

"."{DIGIT}+         |
{DIGIT}+"."{DIGIT}* |
{DIGIT}+("."{DIGIT}+)?{E}+      {
                                    axlval.string = strdup(axtext);
                                    return L_DOUBLE;
                                }

([_]|{LETTER})([_]|{LETTER}|{DIGIT})*   {
                                            axlval.string = strdup(axtext);
                                            return IDENTIFIER;
                                        }

.                           {
                                /* error on everything else */
                                // note that this doesn't call through to yyerrror. This
                                // allows us to catch errors easily but is limited to the first
                                // invalid token.
                                // @todo add a proper error manager to the parser
                                std::ostringstream os;
                                os << axlloc.first_line << ":" << axlloc.first_column
                                   << " Stray or invalid character '"
                                   << axtext << "'";
                                OPENVDB_THROW(openvdb::LLVMSyntaxError, os.str());
                            }

%%

// Copyright (c) 2015-2019 DNEG
// All rights reserved. This software is distributed under the
// Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
